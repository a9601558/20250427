const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-qIlPC0Km.js","assets/index-Ckgs7kKW.css"])))=>i.map(i=>d[i]);
import{_ as c}from"./index-qIlPC0Km.js";const l={async getAllQuestionSets(){try{const{questionSetService:r}=await c(async()=>{const{questionSetService:o}=await import("./index-qIlPC0Km.js").then(e=>e.a);return{questionSetService:o}},__vite__mapDeps([0,1])),t=await r.getAllQuestionSets();return t.success&&t.data?(console.log(`[QuestionSetService] Fetched ${t.data.length} question sets, adding question counts...`),{success:!0,data:await Promise.all(t.data.map(async e=>{try{const n=await this.getQuestionCount(e.id);if(n>0)return console.log(`[QuestionSetService] Successfully got count for "${e.title}": ${n}`),{...e,questionCount:n};{console.warn(`[QuestionSetService] Zero count for "${e.title}", checking for embedded counts...`);const i=Array.isArray(e.questions)?e.questions.length:0,a=Array.isArray(e.questionSetQuestions)?e.questionSetQuestions.length:0,u=typeof e.questionCount=="number"?e.questionCount:0,s=Math.max(i,a,u);return s>0?(console.log(`[QuestionSetService] Using embedded count for "${e.title}": ${s}`),{...e,questionCount:s}):(console.warn(`[QuestionSetService] Unable to determine count for "${e.title}", using 0`),{...e,questionCount:0})}}catch(n){console.error(`[QuestionSetService] Error getting count for "${e.title}" (${e.id}):`,n);const i=Array.isArray(e.questions)?e.questions.length:0,a=Array.isArray(e.questionSetQuestions)?e.questionSetQuestions.length:0,u=typeof e.questionCount=="number"?e.questionCount:0,s=Math.max(i,a,u);return s>0?(console.log(`[QuestionSetService] Using fallback count for "${e.title}": ${s}`),{...e,questionCount:s}):{...e,questionCount:0}}}))}):t}catch(r){return console.error("[QuestionSetService] Error in getAllQuestionSets:",r),{success:!1,error:r.message}}},async getQuestionSetsByCategory(r){try{const{questionSetService:t}=await c(async()=>{const{questionSetService:o}=await import("./index-qIlPC0Km.js").then(e=>e.a);return{questionSetService:o}},__vite__mapDeps([0,1]));return t.getQuestionSetsByCategory(r)}catch(t){return{success:!1,error:t.message}}},async getAllCategories(){try{const{questionSetService:r}=await c(async()=>{const{questionSetService:t}=await import("./index-qIlPC0Km.js").then(o=>o.a);return{questionSetService:t}},__vite__mapDeps([0,1]));return r.getAllCategories()}catch(r){return{success:!1,error:r.message}}},async getQuestionSetById(r){try{const{questionSetService:t}=await c(async()=>{const{questionSetService:o}=await import("./index-qIlPC0Km.js").then(e=>e.a);return{questionSetService:o}},__vite__mapDeps([0,1]));return t.getQuestionSetById(r)}catch(t){return{success:!1,error:t.message}}},async createQuestionSet(r){try{const{questionSetService:t}=await c(async()=>{const{questionSetService:o}=await import("./index-qIlPC0Km.js").then(e=>e.a);return{questionSetService:o}},__vite__mapDeps([0,1]));return t.createQuestionSet(r)}catch(t){return{success:!1,error:t.message}}},async updateQuestionSet(r,t){try{const{questionSetService:o}=await c(async()=>{const{questionSetService:e}=await import("./index-qIlPC0Km.js").then(n=>n.a);return{questionSetService:e}},__vite__mapDeps([0,1]));return o.updateQuestionSet(r,t)}catch(o){return{success:!1,error:o.message}}},async deleteQuestionSet(r){try{const{questionSetService:t}=await c(async()=>{const{questionSetService:o}=await import("./index-qIlPC0Km.js").then(e=>e.a);return{questionSetService:o}},__vite__mapDeps([0,1]));return t.deleteQuestionSet(r)}catch(t){return{success:!1,error:t.message}}},async updateQuestionCount(r){try{if(console.log(`[QuestionSetService] Updating question count for ${r}`),!r)return console.error("[QuestionSetService] Invalid questionSetId provided to updateQuestionCount"),{success:!1,error:"Invalid question set ID"};const t=await this.getQuestionCount(r);return console.log(`[QuestionSetService] Successfully retrieved count for ${r}: ${t}`),{success:!0,data:{questionCount:t},message:`Updated question count: ${t}`}}catch(t){return console.error(`[QuestionSetService] Error updating question count for ${r}:`,t),{success:!1,error:t.message}}},async getQuestionCount(r){try{if(console.log(`[QuestionSetService] Getting question count for ${r}`),!r)return console.error("[QuestionSetService] Invalid questionSetId provided to getQuestionCount"),0;const t=await fetch(`/api/questions/count/${r}`);if(!t.ok)return console.error(`[QuestionSetService] Error fetching question count: API returned ${t.status}`),0;const o=await t.json();return console.log(`[QuestionSetService] Question count response for ${r}:`,o),o&&typeof o.count=="number"?o.count:o&&o.data&&typeof o.data.count=="number"?o.data.count:o&&typeof o.data=="number"?o.data:(console.warn(`[QuestionSetService] Could not find count in response for ${r}:`,o),0)}catch(t){return console.error(`[QuestionSetService] Error getting question count for ${r}:`,t),0}},async batchAddQuestions(r,t){try{const o=localStorage.getItem("token");if(!o)return{success:!1,error:"Authentication required"};let e=null,n=0;t&&(t(10),e=window.setInterval(()=>{n+=5,n<90&&t(n)},500));const i=r.get("questionSetId");if(!i)return{success:!1,error:"No questionSetId provided"};const a=`/api/questions/batch-upload/${i}`;console.log(`Sending batch upload request to: ${a}`);const u=await fetch(a,{method:"POST",headers:{Authorization:`Bearer ${o}`},body:r});e!==null&&clearInterval(e),t&&t(100);const s=await u.json();if(!u.ok)return console.error(`Batch upload failed: ${u.status} ${u.statusText}`,s),{success:!1,error:s.message||`Server returned ${u.status}`};try{console.log(`[QuestionSetService] Refreshing question count for set ${i}`),await this.updateQuestionCount(i),console.log(`[QuestionSetService] Successfully refreshed question count for set ${i}`)}catch(S){console.error(`[QuestionSetService] Failed to update question count for ${i}:`,S)}return{success:!0,data:{success:s.successCount||0,failed:s.failedCount||0,errors:s.errors||[]},message:s.message||"Questions added successfully"}}catch(o){return console.error("Batch upload error:",o),{success:!1,error:o.message}}}},f=async(r,t=!1)=>{console.log(`[QuestionSetService] Refreshing counts for ${r.length} question sets (forceAll: ${t})`);const o=await Promise.all(r.map(async e=>{try{if(!e.id)return console.warn("[QuestionSetService] Skipping count refresh for question set with no ID"),e;if(typeof e.questionCount=="number"&&e.questionCount>0&&!t)return console.log(`[QuestionSetService] Skipping refresh for "${e.title}", already has count: ${e.questionCount}`),e;const i=await l.getQuestionCount(e.id);return console.log(`[QuestionSetService] Refreshed count for "${e.title}": ${i}`),{...e,questionCount:i}}catch(n){return console.error(`[QuestionSetService] Error refreshing count for "${e.title}":`,n),e}}));return console.log(`[QuestionSetService] Successfully refreshed ${o.length} question set counts`),o};export{l as default,l as questionSetService,f as refreshQuestionCounts};
